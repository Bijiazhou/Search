//
// Created by 岳晨阳 on 2019/12/18.
//

/*
 题目描述
在这个著名的游戏中，在一个方形的盘上放置了固定数量和形状的船只，每只船却不能碰到其它的船。在这个题中，我们仅考虑船是方形的，所有的船只都是由图形组成的方形。编写程序求出该棋盘上放置的船只的总数。

输入数据
输入文件头一行由用空格隔开的两个整数 R 和 C 组成， 1≤ R,C≤ 1000 ，这两个数分别表示游戏棋盘的行数和列数。接下来的 R 行每行包含 C 个字符，每个字符可以为“#”，也可为“.”，“#”表示船只的一部分，“.”表示水。
输出数据
为每一个段落输出一行解。如果船的位置放得正确（即棋盘上只存在相互之间不能接触的方形，如果两个“#”号上下相邻或左右相邻却分属两艘不同的船只，则称这两艘船相互接触了）。就输出一段话“There are S ships.”,S表示船只的数量。否则输出“Bad placement.”。
样例输入
6 8
.....#.#
##.....#
##.....#
.......#
#......#
#..#...#

样例输出
There are 5 ships.
 */

#include <cstdio>
#include <cstring>

int dx[2][2]={{0,1},{1,0}}; //剪枝，不一定非要判断上下左右，只用判断右和下，因为左，下是已经判断过的，在判断一次就大大多了循环时间

int que[1000001][2],b[1001][1001],a[1001][1001],n,m,l;
/* que是队列，b是存储是否走过，a是存储原本的.#,
n,m是边界，l是判断是否有两个相邻的船，方便输出*/
int pd(int i,int j) //如思路所述的判断两个矩阵的
{
    if (a[i][j]==1)
    {
        if (a[i+1][j-1]==1)
        {
            if (a[i+1][j]==0 || a[i][j-1]==0)
            {
                return 1;
            }
        }
        if (a[i+1][j+1]==1)
        {
            if (a[i+1][j]==0 || a[i][j+1]==0)
            {
                return 1;
            }
        }
        if (a[i-1][j-1]==1)
        {
            if (a[i][j-1]==0 || a[i-1][j]==0)
            {
                return 1;
            }
        }
        if (a[i-1][j+1]==1)
        {
            if (a[i-1][j]==0 || a[i][j+1]==0)
            {
                return 1;
            }
        }
    }
    return 0;
}
//广度优先搜索
void BFS(int x,int y,int k) //BFS，这里的k可以省略，因为没什么用
{
    int tail=1,head=0,i,x1,y1;
    que[tail][0]=x;
    que[tail][1]=y; //源结点入队列
    b[x][y]=1; //标记判断过
    do
    {
        head++;
        for (i=0;i<2;i++)
        {
            x1=que[head][0]+dx[i][0];
            y1=que[head][1]+dx[i][1]; //扩展的坐标

            if (pd(x1,y1)==1)
            {
                l=1;
                return ;
            } //先判断旁边有没有别的船是相邻的，有的话就不用搜索了

            if (x1>=1 && x1<=n && y1>=1 && y1<=m && a[x1][y1]==1 && b[x1][y1]==0) //判断边界，判断走没走过，判断是不是#
            {
                tail++;
                que[tail][0]=x1;
                que[tail][1]=y1; //拓展新的结点
                b[x1][y1]=1; //标记走过
                a[x1][y1]=k; //这里是为了辨别别的船，根据推敲，也不需要这一行，因为b数组的作用已经体现了，因此整个函数的int k也可以删去的
            }
        }

    }while (head<tail);
}
int main()
{

    char ch[10001];
    int total=0,i,j,k=1;
    scanf("%d%d",&n,&m);
    for (i=1;i<=n;i++)
    {
        scanf("%s",ch); //输入的格式没有空格，因此需要先录入一个字符串
        for (j=0;j<=strlen(ch)-1;j++) //进行字符串存储到a数组里
        {
            if (ch[j]=='#')
                a[i][j+1]=1; //如果是船体的一部分#
            else //如果是海“.”
                a[i][j+1]=0;
        }
    }
    for (i=1;i<=n;i++)
    {
        for (j=1;j<=m;j++) //搜索
        {
            if (a[i][j]==1 && b[i][j]==0) //如果这个地方是船体，并且没有走过
            {
                k++; //可不要
                BFS(i,j,k); //进行循环，将这里这一片所连在一起的#进行标记判断
                total++; //船数量+1
            }
        }
    }
    if (l==1)
    {
        printf("Bad placement.\n");
    } //如果有船体相邻的
    else
        printf("There are %d ships.\n",total); //否则就输出船只数
    return 0;
}